name: Deploy to Environment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
      stack:
        description: 'Stack to deploy (odoo18-staging, odoo18-prod, erp-seisei, etc.)'
        required: true
        type: string
      image_tag:
        description: 'Image tag (must be sha-xxxxxxx format, e.g., sha-abc123)'
        required: true
        type: string
      break_glass:
        description: '[PRODUCTION ONLY] Emergency bypass of verified gate'
        required: false
        type: boolean
        default: false
      break_glass_reason:
        description: '[Required with break_glass] Emergency reason'
        required: false
        type: string

permissions:
  contents: read

env:
  SSH_HOST: ${{ secrets.DEPLOY_SSH_HOST || '54.65.127.141' }}
  SSH_USER: ${{ secrets.DEPLOY_SSH_USER || 'ubuntu' }}
  REPO_PATH: /opt/seisei-odoo-addons

jobs:
  deploy:
    name: Deploy ${{ inputs.stack }} to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    # Use GitHub Environments for protection rules (approval, secrets, etc.)
    environment: ${{ inputs.environment }}

    steps:
      - name: Validate inputs
        run: |
          STACK="${{ inputs.stack }}"
          ENV="${{ inputs.environment }}"
          IMAGE_TAG="${{ inputs.image_tag }}"
          BREAK_GLASS="${{ inputs.break_glass }}"
          BREAK_GLASS_REASON="${{ inputs.break_glass_reason }}"

          # Validate image tag format
          if [[ ! "$IMAGE_TAG" =~ ^sha-[a-f0-9]{7}$ ]]; then
            echo "::error::Invalid image_tag format: $IMAGE_TAG"
            echo "::error::Must be sha-xxxxxxx (7 hex chars)"
            exit 1
          fi

          # Validate stack
          case "$STACK" in
            odoo18-staging|odoo18-prod|erp-seisei|erp-seisei-staging|ocr)
              ;;
            *)
              echo "::error::Unknown stack: $STACK"
              echo "::error::Supported: odoo18-staging, odoo18-prod, erp-seisei, erp-seisei-staging, ocr"
              exit 1
              ;;
          esac

          # Validate break-glass logic
          if [ "$BREAK_GLASS" = "true" ]; then
            if [ "$ENV" != "production" ]; then
              echo "::warning::break_glass only meaningful for production"
            fi
            if [ -z "$BREAK_GLASS_REASON" ]; then
              echo "::error::break_glass requires break_glass_reason"
              exit 1
            fi
          fi

          echo "### Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Stack:** \`$STACK\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** \`$ENV\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** \`$IMAGE_TAG\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Actor:** \`${{ github.actor }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Run ID:** \`${{ github.run_id }}\`" >> $GITHUB_STEP_SUMMARY
          if [ "$BREAK_GLASS" = "true" ]; then
            echo "- **⚠️ Break-glass:** \`$BREAK_GLASS_REASON\`" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history to resolve short SHA

      - name: Extract and resolve SHA from image_tag
        id: extract_sha
        run: |
          IMAGE_TAG="${{ inputs.image_tag }}"
          SHA7=$(echo "$IMAGE_TAG" | sed 's/^sha-//')
          echo "sha7=$SHA7" >> $GITHUB_OUTPUT

          # Resolve short SHA to full SHA
          FULL_SHA=$(git rev-parse $SHA7)
          echo "full_sha=$FULL_SHA" >> $GITHUB_OUTPUT
          echo "Resolved $SHA7 to $FULL_SHA"

      - name: Download digest manifest from build
        uses: dawidd6/action-download-artifact@v3
        with:
          # Download from the build workflow (cross-workflow artifact download)
          workflow: build_ghcr.yml
          # Match artifact by name
          name: image-digests
          path: dist
          # Match by exact commit SHA
          commit: ${{ steps.extract_sha.outputs.full_sha }}
          # Allow searching through recent workflow runs
          search_artifacts: true
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify digest manifest
        run: |
          if [ ! -f dist/image-digests.json ]; then
            echo "::error::Digest manifest not found: dist/image-digests.json"
            echo "::error::Make sure build workflow has run for this image_tag"
            exit 1
          fi

          echo "Digest manifest content:"
          cat dist/image-digests.json

          # Validate JSON
          jq empty dist/image-digests.json || {
            echo "::error::Invalid JSON in digest manifest"
            exit 1
          }

          # Validate manifest contains our image_tag
          MANIFEST_TAG=$(jq -r '.git_sha7' dist/image-digests.json)
          EXPECTED_TAG="${{ inputs.image_tag }}"
          EXPECTED_SHA7=$(echo "$EXPECTED_TAG" | sed 's/^sha-//')

          if [ "$MANIFEST_TAG" != "$EXPECTED_SHA7" ]; then
            echo "::error::Digest manifest SHA mismatch"
            echo "::error::Expected: $EXPECTED_SHA7, Got: $MANIFEST_TAG"
            echo "::error::Make sure you downloaded the correct build artifact"
            exit 1
          fi

          echo "✅ Digest manifest validated"

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Add known_hosts
          ssh-keyscan -H ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Upload digest manifest to server
        run: |
          # Upload digest manifest to server temp directory
          scp -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=accept-new \
            dist/image-digests.json \
            ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/image-digests.json

          echo "✅ Digest manifest uploaded to server: /tmp/image-digests.json"

      - name: Deploy to server
        id: deploy
        run: |
          STACK="${{ inputs.stack }}"
          ENV="${{ inputs.environment }}"
          IMAGE_TAG="${{ inputs.image_tag }}"
          BREAK_GLASS="${{ inputs.break_glass }}"
          BREAK_GLASS_REASON="${{ inputs.break_glass_reason }}"
          ACTOR="${{ github.actor }}"
          RUN_ID="${{ github.run_id }}"

          echo "::group::Deploying $STACK ($ENV) with $IMAGE_TAG"

          # Build deploy command
          DEPLOY_CMD="sudo ${{ env.REPO_PATH }}/scripts/deploy.sh \"$STACK\" \"$ENV\" \"$IMAGE_TAG\" \
            --digest-file /tmp/image-digests.json \
            --actor \"$ACTOR\" \
            --run-id \"$RUN_ID\""

          if [ "$BREAK_GLASS" = "true" ]; then
            DEPLOY_CMD="$DEPLOY_CMD --break-glass --reason \"$BREAK_GLASS_REASON\""
          fi

          # Execute deployment via SSH (NO git pull - immutable release pattern)
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=accept-new \
            -o ConnectTimeout=10 \
            ${{ env.SSH_USER }}@${{ env.SSH_HOST }} bash -s <<ENDSSH
          set -euo pipefail

          echo "=========================================="
          echo "Image as Source of Truth Deployment"
          echo "Stack:       $STACK"
          echo "Environment: $ENV"
          echo "Image Tag:   $IMAGE_TAG"
          echo "Actor:       $ACTOR"
          echo "Run ID:      $RUN_ID"
          echo "=========================================="
          echo ""

          # Verify digest file exists on server
          if [ ! -f /tmp/image-digests.json ]; then
            echo "::error::Digest manifest not found on server: /tmp/image-digests.json"
            exit 1
          fi

          echo "Digest manifest on server:"
          cat /tmp/image-digests.json
          echo ""

          # Ensure scripts are executable (deploy.sh should exist in /opt repo)
          chmod +x ${{ env.REPO_PATH }}/scripts/*.sh

          # Execute deploy script
          # NO git pull - code in /opt is for scripts only
          # Runtime state is managed through /srv/releases/stacks
          $DEPLOY_CMD 2>&1 | tee /tmp/deploy.log

          # Check exit status
          EXIT_CODE=\${PIPESTATUS[0]}
          if [ \$EXIT_CODE -eq 0 ]; then
            echo ""
            echo "✅ Deployment successful"

            # Display current manifest
            if [ -f /srv/releases/current/${STACK}.json ]; then
              echo ""
              echo "Current deployment manifest:"
              cat /srv/releases/current/${STACK}.json | jq .
            fi

            exit 0
          else
            echo ""
            echo "❌ Deployment failed (exit code: \$EXIT_CODE)"
            exit \$EXIT_CODE
          fi
          ENDSSH

          echo "::endgroup::"

          # Set output based on result
          if [ $? -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Capture deployment results
        if: always()
        run: |
          STACK="${{ inputs.stack }}"
          ENV="${{ inputs.environment }}"
          IMAGE_TAG="${{ inputs.image_tag }}"

          echo "### Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** \`${{ steps.deploy.outputs.status || 'failed' }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get deployment details from server
          ssh -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=accept-new \
            ${{ env.SSH_USER }}@${{ env.SSH_HOST }} bash -s <<'ENDSSH' >> $GITHUB_STEP_SUMMARY

          echo "**Current deployment manifest:**"
          echo '```json'
          cat /srv/releases/current/${{ inputs.stack }}.json 2>/dev/null | jq . || echo "Manifest not found"
          echo '```'
          echo ""

          echo "**Recent deployment history:**"
          echo '```'
          grep "${{ inputs.stack }}" /srv/releases/deploy_history.log 2>/dev/null | tail -5 || echo "No history found"
          echo '```'
          echo ""

          echo "**Running containers:**"
          echo '```'
          cd /srv/stacks/${{ inputs.stack }} 2>/dev/null && sudo docker compose ps || echo "Stack not found"
          echo '```'
          echo ""

          echo "**Symlink verification:**"
          echo '```'
          readlink -f /srv/stacks/${{ inputs.stack }} || echo "Symlink not found"
          echo '```'
          ENDSSH

      - name: Cleanup SSH key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
